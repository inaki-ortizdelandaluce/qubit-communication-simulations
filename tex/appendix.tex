\subsection{qubit.py}\label{section:listing_qubit}
This module provides basic operations for qubit pure states either in two-dimensional the Hilbert space $\mathcal{H}$ or in the Bloch sphere $S_2$. 
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
breaklines
]{python}
import numpy as np
import cmath
import math

X = np.array([[0, 1], [1, 0]])
Y = np.array([[0, -1.j], [1j, 0]])
Z = np.array([[1, 0], [0, -1]])


class Qubit:
    def __init__(self, ket=np.array([1, 0])):
        """
        Initializes a qubit in the computational basis. If no arguments are provided, it returns the zero state.

        Parameters
        ---------
        ket : ndarray
            The qubit components in the computational basis in a 1-d complex array.
        """
        self.alpha = complex(ket[0])
        self.beta = complex(ket[1])
        self.normalize()

    def __repr__(self):
        return '{} |0> + {} |1>'.format(self.alpha, self.beta)

    def ket(self):
        return np.array([self.alpha, self.beta], dtype=np.complex_)

    def normalize(self):
        arr = self.ket()
        self.alpha, self.beta = arr/np.linalg.norm(arr)

    def rho(self):
        """
         Returns the density matrix corresponding to the qubit in a pure state.

         Returns
         -------
         ndarray
             A 2x2 density matrix corresponding to the qubit in a pure state.
         """
        return np.outer(self.ket(), self.ket().conj())

    def bloch_angles(self):
        """
        Returns the spherical coordinates of the qubit in the Bloch sphere, with polar and azimuthal angles in radians.

        Returns
        -------
        (float, float)
            The Bloch sphere coordinates, first the polar angle and then the azimuthal angle (both in radians).
        """
        r0, phi0 = cmath.polar(self.alpha)
        r1, phi1 = cmath.polar(self.beta)
        theta = 2 * math.acos(r0)
        phi = phi1 - phi0

        return theta, phi

    @staticmethod
    def density2bloch(rho):
        """
        Returns the cartesian coordinates of the specified qubit state in the Bloch sphere.

        Parameters
        ---------
        rho : ndarray
            The qubit state in density matrix form

         Returns
         -------
         (float, float, float)
             The cartesian coordinates of the qubit in the Bloch sphere (xyz).

        """
        # cast complex to real to avoid throwing ComplexWarning, imaginary part should always be zero
        return [np.real(np.trace(np.matmul(rho, sigma))) for sigma in np.array([X, Y, Z])]

    def bloch_vector(self):
        """
         Returns the cartesian coordinates of the qubit in the Bloch sphere.

         Returns
         -------
         (float, float, float)
             The cartesian coordinates of the qubit in the Bloch sphere (xyz).

         """
        return Qubit.density2bloch(self.rho())
\end{minted}
\newpage
\subsection{measurement.py}\label{section:listing_measurement}
This module implements projection-valued measures and rank-1 positive operator-valued measures for qubit states. 
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
breaklines
]{python}
import numpy as np
import scipy
from qt.qubit import Qubit


class PVM:
    def __init__(self, proj):
        """
        Creates a PVM with the specified rank-1 projectors.

        Parameters
        ---------
        proj : ndarray
            A 3-d array with the constituting rank-1 projectors.
       """
        # check input
        if not np.allclose(np.identity(2), np.sum(proj, axis=0)):
            raise ValueError('PVM projectors do not sum up the identity')

        self.proj = proj
        self.bloch = np.asarray([Qubit.density2bloch(p) for p in proj])

    @classmethod
    def new(cls, qubit: Qubit):
        """
        Creates a PVM with the rank-1 projectors corresponding to the specified qubit state.

        Parameters
        ---------
        qubit : Qubit
            The specified qubit state from which the two rank-1 projectors are generated.
        """
        rho = qubit.rho()
        sigma = np.identity(2) - rho
        proj = np.array([rho, sigma])
        return cls(proj)

    def projector(self, index):
        """
        Returns rank-1 projector for the corresponding index

        Parameters
        ---------
        index : the projector index

        Returns
        -------
        ndarray
            A 2-d array with the corresponding projector.
        """
        return self.proj[index]

    def probability(self, qubit: Qubit):
        """
        Returns the probabilities of the different outcomes for a given qubit state

        Parameters
        ---------
        qubit : the qubit state

        Returns
        -------
        ndarray
            The probabilities for each outcome given the input state, stored in a 1-d array.
        """

        # repeat density matrix along zero axis
        rho = qubit.rho()
        rho = np.repeat(rho[np.newaxis, :, :], self.proj.shape[0], axis=0)

        # compute trace of projectors by density matrix
        return np.real(np.trace(np.matmul(self.proj, rho), axis1=1, axis2=2))


class POVM:

    def __init__(self, weights, proj):
        """
        Creates a POVM with the specified weights and rank-1 projectors.

        Parameters
        ---------
        weights : ndarray
            The positive coefficients of the constituting rank-1 projectors.

        proj : ndarray
            A 3-d array with the constituting rank-1 projectors.
        """
        self.weights = weights
        self.elements = proj * weights[:, np.newaxis, np.newaxis]

        # check input
        if not np.allclose(np.identity(2), np.sum(self.elements, axis=0)):
            raise ValueError('POVM elements do not sum up the identity')

        positive = [np.all(np.linalg.eig(element)[0] >= -np.finfo(np.float32).eps) for element in self.elements]
        if not np.all(positive):
            raise ValueError('Some POVM elements are not definite positive')

        self.bloch = v = np.asarray([Qubit.density2bloch(p) for p in proj])

    @classmethod
    def new(cls, qubits):
        """
        Creates a POVM with the rank-1 projectors corresponding to the specified qubit states.

        Parameters
        ---------
        qubits : ndarray
           The specified array of N-2 qubit states from which the N rank-1 POVM projectors are generated.
        """
        # last element normalizes all POVM elements
        rhos = np.asarray([q.rho() for q in qubits])
        e = np.identity(2) - np.sum(rhos, axis=0)

        # diagonalize last element to obtain remaining rank-1 projectors
        _, w = np.linalg.eig(e)
        q1 = Qubit(w[:, 0])
        q2 = Qubit(w[:, 1])
        qubits = np.append(qubits, np.array([q1, q2]), axis=0)

        # compute POVM weights and elements as a linear program (see Sent√≠s et al. 2013)
        v = np.asarray([q.bloch_vector() for q in qubits])
        n = len(qubits)

        a = np.vstack((np.ones((n,)), v.T))
        b = np.append(np.array([2]), np.zeros(3, ), axis=0)

        lp = scipy.optimize.linprog(np.zeros(n, ), A_eq=a, b_eq=b, bounds=(0.01, 1), method='highs')
        _a, _e = lp['x'], np.asarray([q.rho() for q in qubits])

        return cls(_a, _e)

    def element(self, index):
        """
        Returns the POVM element for the corresponding index

        Parameters
        ---------
        index : the POVM element index

        Returns
        -------
        ndarray
            A 2-d array with the corresponding POVM element.
        """
        return self.element[index]

    def probability(self, qubit: Qubit):
        """
        Returns the probabilities of the different outcomes for a given qubit state

        Parameters
        ---------
        qubit : the qubit state

        Returns
        -------
        ndarray
            The probabilities for each outcome given the input state, stored in a 1-d array.
        """

        # repeat density matrix along zero axis
        rho = qubit.rho()
        rho = np.repeat(rho[np.newaxis, :, :], self.elements.shape[0], axis=0)

        # compute trace of projectors by density matrix
        return np.real(np.trace(np.matmul(self.elements, rho), axis1=1, axis2=2))

    def size(self):
        """
        Returns the number of POVM elements

        Returns
        -------
        int
            The number of POVM elements.
        """
        return np.size(self.elements, axis=0)

    def unitary(self):
        """
        Returns the associated unitary matrix in the extended Hilbert space according to Neumark's theorem

        Returns
        -------
        ndarray
            The nxn unitary matrix where n is the number of POVM elements.

        """
        d = 2
        n = self.size()
        u = np.zeros((n, n), dtype=np.complex_)

        # compute the kets of the rank-1 POVM projectors and assign to first d columns
        # v, _, _ = np.linalg.svd(self.elements, full_matrices=True, compute_uv=True, hermitian=False)
        # u[:, 0:d] = v[:, :, 0] / np.linalg.norm(v[:, :, 0], axis=0)
        w, v = np.linalg.eig(self.elements)
        v = v[np.where(w != 0)]
        u[:, 0:d] = v / np.linalg.norm(v, axis=0)

        # remaining n-d columns should correspond to orthogonal projectors in extended space
        p = np.eye(n, dtype=np.complex_)
        for idx in range(d):
            p -= np.outer(u[:, idx], u[:, idx].conj())

        counter = 0
        for b in np.eye(n, dtype=np.complex_):
            w = np.matmul(p, b)
            if not np.isclose(w, 0.0).all():
                w /= np.linalg.norm(w)
                u[:, counter + d] = w
                p -= np.outer(w, w.conj())
                counter += 1
            if counter == (n - d):
                break

        if not np.allclose(np.matmul(u, u.conj().T), np.eye(n)):
            raise ValueError('Neumark\'s square matrix is not unitary')

        return u
\end{minted}
\newpage
\subsection{random.py}\label{section:listings_random}
This module provides means to create random qubit states and random measurements using object classes available on \ref{section:listing_qubit} and \ref{section:listing_measurement} modules. 
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
breaklines
]{python}
import math
import numpy as np
from qt.qubit import Qubit
from qt.measurement import PVM, POVM


def bloch_vector():
    """
    Generates a normalised vector uniformly distributed on the Bloch sphere

    Returns
    -------
    ndarray
            A normalised vector on the Bloch sphere

    """
    theta, phi = qubit().bloch_angles()
    return np.array([math.sin(theta) * math.cos(phi),
                     math.sin(theta) * math.sin(phi),
                     math.cos(theta)])


def qubit():
    """
    Generates a random qubit.

    Returns
    -------
    Qubit
        A random Qubit.
    """
    # evolve the zero state with a random unitary matrix
    # same as returning first column of random unitary matrix
    u = unitary((2, 2))
    return Qubit(u[:, 0])


def pvm():
    """
    Generates a random projection value measure for a qubit

    Returns
    -------
    PVM
            A projection value measure instance.
    """
    q = qubit()
    measurement = PVM.new(q)
    return measurement


def povm(n):
    """
    Generates a random positive operator value measure for a qubit

    Parameters
    ---------
    n : int
        Number of POVM elements. Must be greater than two.

    Returns
    -------
    PVM
            A positive operator value measure instance.
    """
    if n <= 2:
        raise ValueError('Number of POVM elements must be greater thant two')

    qubits = [qubit() for _ in range(n - 2)]
    measurement = POVM.new(qubits)
    return measurement


def unitary(shape):
    """
    Generates a random unitary matrix with the given shape.

    Parameters
    ---------
    shape : int or tuple of ints
        Shape of the unitary matrix.

    Returns
    -------
    ndarray
        Unitary matrix with the given shape.
    """
    # build random complex matrix
    m = np.random.normal(0, 1, shape) + 1.j * np.random.normal(0, 1, shape)

    # apply Gram-Schmidt QR decomposition to orthogonalize the matrix
    q, *_ = np.linalg.qr(m, mode='complete')

    return q
\end{minted}
\newpage
\subsection{classical.py}\label{section:listings_classical}
This module implements the classical prepare-and-measure and Bell simulation protocols. 
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
breaklines
]{python}
import numpy as np
import random
import qt.random
from qt.qubit import Qubit
from qt.measurement import PVM, POVM


def heaviside(a):
    if isinstance(a, np.ndarray):
        return (a >= 0).astype(int)
    else:
        return int(a >= 0)


def theta(a):
    return a * heaviside(a)


def prepare(lambdas, qubit):
    """
    Alice prepares and sends two bits to Bob

    Parameters
    ---------
    lambdas : ndarray
        Shared randomness as two normalized vectors in a numpy 2-d array

    qubit: Qubit
        A uniformly sampled pure state qubit

    Returns
    -------
    dict
        A dictionary with the shared randomness ('lambdas'), the random qubit ('qubit')
        and the bits to be communicated to Bob ('bits')
    """

    x = qubit.bloch_vector()
    bits = heaviside(np.matmul(x, lambdas.T))
    return {
        "lambdas": lambdas,
        "qubit": qubit,
        "bits": bits
    }


def measure_pvm(lambdas, bits, measurement: PVM):
    """
    Bob receives two bits from Alice and performs a random PVM

    Parameters
    ---------
    lambdas : ndarray
        Shared randomness as two normalized vectors in a numpy 2-d array

    bits: ndarray
        Bits communicated by Alice in a numpy 1-d array

    measurement: PVM
        A uniformly sampled PVM

    Returns
    -------
    dict
        A dictionary with the random measurement ('measurement') and
        the probabilities for each measurement outcome ('probabilities')
    """
    # flip shared randomness
    flip = np.where(bits == 0, -1, 1).reshape(2, 1)
    lambdas = np.multiply(lambdas, flip)

    # pick bloch vectors from PVM elements
    y = measurement.bloch
    pb = 0.5 * np.array([1, 1])

    # compute lambda according to the probabilities {pb}
    index = random.choices(range(0, 2), cum_weights=np.cumsum(pb), k=1)[0]
    a = np.abs(np.matmul(lambdas, y.T))
    _lambda = lambdas[np.argmax(a, axis=0)[index]]

    # compute probabilities
    thetas = theta(np.matmul(y, _lambda.reshape(-1, 1)))
    weighted_thetas = np.multiply(thetas, pb.reshape(-1, 1))
    p = weighted_thetas[:, 0] / np.sum(weighted_thetas, axis=0)

    return {
        "measurement": measurement,
        "probabilities": p
    }


def prepare_and_measure_pvm(shots):
    """
    Runs a prepare-and-measure classical simulation with a random PVM measurement

    Parameters
    ---------
    shots : int
        Number of shots the simulation is run with

    Returns
    -------
    dict
        A dictionary with the random state ('qubit'), random PVM measurement ('measurement') and
        the probabilities for each measurement outcome ('probabilities') in a nested structure including the
        theoretical probability ('born'), the execution runs ('runs') and the probability statistics ('stats')
    """

    # Alice prepares a random qubit
    qubit = qt.random.qubit()

    # Bob prepares a random measurement
    measurement = qt.random.pvm()

    experiment = {
        "qubit": qubit,
        "measurement": measurement,
        "probabilities": {
            "runs": np.zeros((shots, 2)),
            "stats": np.zeros((2,)),
            "born": np.ones((2,))
        }
    }

    for i in range(shots):

        # Alice and Bob's shared randomness
        shared_randomness = np.array([qt.random.bloch_vector(), qt.random.bloch_vector()])

        # Alice prepares
        alice = prepare(shared_randomness, qubit)

        # Bob measures
        bob = measure_pvm(shared_randomness, alice['bits'], measurement)

        # save simulation runs
        p = np.abs(bob['probabilities'])
        experiment['probabilities']['runs'][i, :] = p

        # accumulate counts according to Bob's probabilities
        index = random.choices(range(0, 2), cum_weights=np.cumsum(p), k=1)[0]
        experiment['probabilities']['stats'][index] = experiment['probabilities']['stats'][index] + 1

    experiment['probabilities']['stats'] = experiment['probabilities']['stats'] / shots
    experiment['probabilities']['born'] = bob['measurement'].probability(qubit)

    return experiment


def measure_povm(lambdas, bits, measurement: POVM):
    """
    Bob receives two bits from Alice and performs a random POVM

    Parameters
    ---------
    lambdas : ndarray
        Shared randomness as two normalized vectors in a numpy 2-d array

    bits: ndarray
        Bits communicated by Alice in a numpy 1-d array

    measurement: POVM
        A uniformly sampled POVM

    Returns
    -------
    dict
        A dictionary with the random measurement ('measurement') and
        the probabilities for each measurement outcome ('probabilities')
    """
    # flip shared randomness
    flip = np.where(bits == 0, -1, 1).reshape(2, 1)
    lambdas = np.multiply(lambdas, flip)

    # pick bloch vectors and weights from POVM elements
    y = measurement.bloch
    pb = measurement.weights / 2.

    # compute lambda according to the probabilities {pb}
    index = random.choices(range(0, measurement.size()), cum_weights=np.cumsum(pb), k=1)[0]
    a = np.abs(np.matmul(lambdas, y.T))
    _lambda = lambdas[np.argmax(a, axis=0)[index]]

    # compute probabilities
    thetas = theta(np.matmul(y, _lambda.reshape(-1, 1)))
    weighted_thetas = np.multiply(thetas, pb.reshape(-1, 1))
    p = weighted_thetas[:, 0] / np.sum(weighted_thetas, axis=0)

    return {
        "measurement": measurement,
        "probabilities": p
    }


def prepare_and_measure_povm(shots, n):
    """
    Runs a prepare-and-measure classical simulation with a random POVM measurement

    Parameters
    ---------
    shots : int
        Number of shots the simulation is run with
    n: int
        Number of POVM random elements

    Returns
    -------
    dict
        A dictionary with the random state ('qubit'), random POVM measurement ('measurement') and
        the probabilities for each measurement outcome ('probabilities') in a nested structure including the
        theoretical probability ('born'), the execution runs ('runs') and the probability statistics ('stats')
    """

    # Alice prepares a random qubit
    qubit = qt.random.qubit()

    # Bob prepares a random measurement
    measurement = qt.random.povm(n)

    experiment = {
        "qubit": qubit,
        "measurement": measurement,
        "probabilities": {
            "runs": np.zeros((shots, n)),
            "stats": np.zeros((n,)),
            "born": np.ones((n,))
        }
    }

    for i in range(shots):

        # Alice and Bob's shared randomness
        shared_randomness = np.array([qt.random.bloch_vector(), qt.random.bloch_vector()])

        # Alice prepares
        alice = prepare(shared_randomness, qubit)

        # Bob measures
        bob = measure_povm(shared_randomness, alice['bits'], measurement)

        # save simulation runs
        p = np.abs(bob['probabilities'])
        experiment['probabilities']['runs'][i, :] = p

        # accumulate counts according to Bob's probabilities
        index = random.choices(range(0, n), cum_weights=np.cumsum(p), k=1)[0]
        experiment['probabilities']['stats'][index] = experiment['probabilities']['stats'][index] + 1

    experiment['probabilities']['stats'] = experiment['probabilities']['stats'] / shots
    experiment['probabilities']['born'] = bob['measurement'].probability(qubit)

    return experiment
\end{minted}
\newpage
\subsection{quantum.py}\label{section:listings_quantum}
This module implements the prepare-and-measure for a given input state and positive operator-valued measure in a quantum simulator using Qiskit. 
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
breaklines
]{python}
import numpy as np
from qiskit import QuantumCircuit, transpile, Aer, IBMQ
from qt.qubit import Qubit
from qt.measurement import POVM


def prepare_and_measure_povm(shots, qubit: Qubit, povm: POVM):
    # TODO extend usage to any POVM of N elements (currently N =4)
    qc = QuantumCircuit(2, 2)
    u = povm.unitary()

    qc.initialize(qubit.ket(), 0)
    qc.unitary(u, [0, 1])
    qc.measure([0, 1], [0, 1])

    backend = Aer.get_backend('aer_simulator')
    qc_transpiled = transpile(qc, backend)

    job = backend.run(qc_transpiled, shots=shots)
    result = job.result()
    counts = result.get_counts(qc_transpiled)

    p = np.array([counts['00'], counts['01'], counts['10'], counts['11']])
    p = p / np.sum(p)

    return p
\end{minted}